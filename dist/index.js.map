{"version":3,"sources":["../node_modules/.pnpm/run-with-worker@1.0.4/node_modules/run-with-worker/src/index.ts","../src/index.ts"],"sourcesContent":["const WORKER_URL = URL.createObjectURL(\n  new Blob([\n    \"onmessage = (m) => (async function(){}).constructor(m.data.funcStr)(m.data.args)\",\n  ]),\n);\n\ntype ExtraReturnFields = { cancel: () => void; worker: Worker };\n\nexport function runWithWorker<T, D extends Readonly<[...any]>>(\n  task: (\n    ...deps: {\n      [i in keyof D]: Awaited<D[i]> extends infer R extends Record<\n        string,\n        unknown\n      >\n        ? R extends { _$trustedScriptUrl: string }\n          ? Awaited<D[i]>\n          : { _$trustedScriptUrl: never } & {\n              [f in keyof R]: R[f] extends Function ? never : R[f];\n            }\n        : Awaited<D[i]>;\n    } & Array<any>\n  ) => T,\n  deps?: Readonly<[...D]>,\n  opts?: { workerOptions?: WorkerOptions; executionTimeoutMs?: number },\n): Promise<T> & ExtraReturnFields {\n  const worker = new Worker(WORKER_URL, opts?.workerOptions);\n\n  let capturedReject: undefined | ((e: unknown) => void);\n  const promise: Promise<T> & Partial<ExtraReturnFields> = new Promise(\n    async (resolve, reject) => {\n      try {\n        capturedReject = reject;\n        const awaitedDeps = await Promise.all(deps ?? []);\n        const args = awaitedDeps.map((d) => {\n          if (typeof d?._$trustedScriptUrl === \"string\") {\n            return {\n              $__trustedScript: `import(${JSON.stringify(d._$trustedScriptUrl)})`,\n            };\n          }\n          return d;\n        });\n        const funcStr = `Promise.all(arguments[0].map(d => d && typeof d.$__trustedScript === 'string' ? eval(d.$__trustedScript) : d)).then(deps => (${task.toString()})(...deps)).then(r=>postMessage(r)).catch(e=>postMessage({$__error:e}))`;\n        worker.onmessage = (m) => {\n          m.data?.$__error ? reject(m.data?.$__error) : resolve(m.data);\n          worker.terminate();\n        };\n        worker.onerror = (e) => {\n          reject(e);\n          worker.terminate();\n        };\n        worker.onmessageerror = (e) => {\n          reject(e);\n          worker.terminate();\n        };\n        if (opts?.executionTimeoutMs != null) {\n          setTimeout(\n            () =>\n              reject(\n                new TaskTimeoutError(\n                  `Task exceeded ${opts.executionTimeoutMs}ms`,\n                ),\n              ),\n            opts.executionTimeoutMs,\n          );\n        }\n        worker.postMessage({ funcStr, args });\n      } catch (e) {\n        reject(e);\n      }\n    },\n  );\n\n  promise.cancel = () => {\n    worker.terminate();\n    capturedReject?.(new TaskCancellationError(\"Task cancelled\"));\n  };\n  promise.worker = worker;\n\n  return promise as Promise<T> & ExtraReturnFields;\n}\n\nexport class TaskCancellationError extends Error {}\nexport class TaskTimeoutError extends Error {}\n","import { runWithWorker } from \"run-with-worker\";\n\n/**\n * Parallel version of `Array.map`.\n * This is a wrapper around `runWithWorker` from the \"run-with-worker\"\n * package, and thus follows the same rules regarding what code is\n * allowed to run inside the computation function, and what is allowed\n * to be passed down in the dependency array.\n */\nexport async function parallelMap<T, D extends Readonly<Array<unknown>>, R>(\n  /**\n   * Number of threads (Web Workers) to run this computation on.\n   * Must be above 0.\n   */\n  threads: number,\n  /**\n   * Array to perform computation on, which will be distributed amongst threads.\n   */\n  arr: Readonly<Array<T>>,\n  /**\n   * The computation to perform on a single item of `arr`.\n   */\n  mapFn: (\n    item: T,\n    deps: Parameters<Parameters<typeof runWithWorker<unknown, D>>[0]>,\n  ) => R,\n  /**\n   * Additional dependencies to provide to `mapFn`, to make up for `mapFn`\n   * not being able to make use of its outer scope. Can include dynamic\n   * imports, as long as they export `_$trustedScriptUrl = import.meta.url`.\n   */\n  deps: [...D],\n): Promise<Array<R>> {\n  if (!threads) {\n    throw new Error(\"Invalid number of threads: \" + threads);\n  }\n  // TODO: Get rid of these awful `any`s\n  const results: unknown[][] = (await Promise.all(\n    splitArr(threads, arr).map((chunk) =>\n      runWithWorker(\n        ((mapFnStr: any, chunk: any, ...deps: any[]) => {\n          const _mapFn: typeof mapFn = eval(mapFnStr);\n          return chunk.map((item: any) => _mapFn(item, deps as any));\n        }) as unknown as any,\n        [mapFn.toString(), chunk, ...deps],\n      ),\n    ),\n  )) as any;\n  return unsplitArrs(threads, results) as any;\n}\n\nfunction splitArr<T>(split: number, arr: Readonly<Array<T>>): Array<Array<T>> {\n  let currentSplit = 0;\n  const splitArrs: Array<Array<T>> = [];\n  for (const item of arr) {\n    splitArrs[currentSplit] ??= [];\n    splitArrs[currentSplit].push(item);\n    currentSplit = (currentSplit + 1) % split;\n  }\n  return splitArrs;\n}\n\nfunction unsplitArrs(\n  split: number,\n  arr: Readonly<Array<Array<unknown>>>,\n): Array<unknown> {\n  const unsplit: unknown[] = [];\n  for (let i = 0; i < split; i++) {\n    for (const chunk of arr) {\n      if (i >= chunk.length) {\n        continue;\n      }\n      unsplit.push(chunk[i]);\n    }\n  }\n  return unsplit;\n}\n"],"mappings":"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","names":["index_exports","__export","runWithWorker","module","__toCommonJS","deps","__async","arr","chunk"]}